{"ast":null,"code":"import _regeneratorRuntime from\"/Users/aross/Desktop/adaptation-profiler/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/aross/Desktop/adaptation-profiler/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import File from'../misc/test.csv';import MNIST from'../config/mnist.json';import csv2array from'./CSVToArray';function Main(_x,_x2,_x3,_x4){return _Main.apply(this,arguments);}function _Main(){_Main=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(histArraySize,stepSize,equation,adapt){var configuration,capacitance,newVoltage,oldVoltage,current,simulationTime,hasBeenMax,rawData,timeArray,accuracyArray,accuracyReturn,bootTime,executedTasks,currentTask,currentTaskNumber,currentTaskIterationNumber,adaptiveVariables,equation1,equation2,equation3,equation4,onTime,avgOnTime,s_onTime,offTime,avgOffTime,s_offTime,appCompletionTime,avgAppCompletionTime,s_appCompTime,taskCount,avgTaskCount,s_taskCount,powerFailureCount,avgpowerFailureCount,s_pFC,lowerAdaptationThreshold,upperAdaptationThreshold,adaptationStepSize,upperThresholdVoltage,lowerThresholdVoltage,stepTime,appCompletions,appCompleted,getData,_getData,initializeAdaptiveVariables,average,executeTasks,calculateNewVoltage,calculateRemainingVoltage,calculateEnergy,findClosestValue,extractTimeArray,extractVoltageArray,findCurrentNow,findAccuracyNow,handleMLAccuracy,adaptUp,adaptDown,adaptiveVariablesValues,closestTimestamp,voltageArray,closestVoltage,energy,usefulEnergy,remainingUsefulEnergy,totalRemainingEnergy,_energy,_usefulEnergy,_remainingUsefulEnergy,_totalRemainingEnergy,mlAccuracy,roundedAccuracy;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_getData=function _getData3(){_getData=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(){var response,table;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return fetch(File);case 2:response=_context4.sent;_context4.next=5;return response.text();case 5:table=_context4.sent;rawData=csv2array(table);case 7:case\"end\":return _context4.stop();}}},_callee4);}));return _getData.apply(this,arguments);};getData=function _getData2(){return _getData.apply(this,arguments);};console.log(\"equation\",equation);// Notes:\n// - button for run simulation\n// - report total executions on UI/UX\n// - loading indicator during executions\n// - at each app completion: find skip rows, and skip columns -> convert to a string in the form of 0_0 -> find value from accuracy dictionary (make a dictionary too) -> average these values -> report this as ML accuracy\n// Configuration\nconfiguration=MNIST.adaptationStrategy[0];// Initial Values\ncapacitance=200e-6;//micro-farads\nnewVoltage=0;//volts\noldVoltage=0;//volts\ncurrent=0;//amperes\nsimulationTime=0;//seconds\nhasBeenMax=false;// Useful Utility Arrays\ntimeArray=[];accuracyArray=[];accuracyReturn=[];// Task Management Logic\nbootTime=0;executedTasks=false;currentTask=configuration.tasks[0];currentTaskNumber=0;currentTaskIterationNumber=0;adaptiveVariables=configuration.adaptiveVariables;// Adaptation Equations\nequation1=equation.adaptUp.split('>');equation2=equation.adaptUp.split('>').pop();equation3=equation.adaptDown.split('<')[0];equation4=equation.adaptDown.split('<').pop();// Adaptation Signals\nonTime=0;avgOnTime=0;s_onTime=new Array(histArraySize+1).fill(0);offTime=0;avgOffTime=0;s_offTime=new Array(histArraySize+1).fill(0);appCompletionTime=0;avgAppCompletionTime=0;s_appCompTime=new Array(histArraySize+1).fill(0);taskCount=0;avgTaskCount=0;s_taskCount=new Array(histArraySize+1).fill(0);powerFailureCount=0;avgpowerFailureCount=0;s_pFC=new Array(histArraySize+1).fill(0);lowerAdaptationThreshold=0;upperAdaptationThreshold=7;adaptationStepSize=stepSize;// Threshold Logic\nupperThresholdVoltage=2.9;//volts\nlowerThresholdVoltage=1.9;//volts\n// Step Logic\nstepTime=0.01;//seconds\n// Global Runs Logic\nappCompletions=0;appCompleted=false;// Functions Library\ninitializeAdaptiveVariables=function initializeAdaptiveVariables(variables){var adaptiveVariablesValues={};for(var i=0;i<variables.length;i++){adaptiveVariablesValues[variables[i]]=0;}return adaptiveVariablesValues;};average=function average(list){return list.reduce(function(prev,curr){return prev+curr;})/list.length;};executeTasks=function executeTasks(energy){var availableEnergy=energy;if(typeof currentTask.taskIterations!=='number'){var taskIterations;for(var i=0;i<currentTask.adaptiveVars.length;i++){window[currentTask.adaptiveVars[i]]=adaptiveVariablesValues[currentTask.adaptiveVars[i]];}taskIterations=eval(currentTask.taskIterations);if(energy>currentTask.energyPerItr){stepTime=currentTask.time;availableEnergy=energy-currentTask.energyPerItr;taskCount=taskCount+currentTask.taskWeight;currentTaskIterationNumber=currentTaskIterationNumber+1;if(taskIterations==currentTaskIterationNumber){console.log(currentTask.taskName);console.log(\"task completion time\",simulationTime);if(currentTask.nextTask!==\"task_init\"){currentTaskIterationNumber=0;currentTaskNumber=currentTaskNumber+1;currentTask=configuration.tasks[currentTaskNumber];}else if(currentTask.nextTask===\"task_init\"){appCompleted=true;}}return availableEnergy;}else{stepTime=currentTask.time*(availableEnergy/currentTask.energyPerItr);hasBeenMax=false;powerFailureCount=powerFailureCount+1;availableEnergy=calculateEnergy(lowerThresholdVoltage);return availableEnergy;}}else{var _taskIterations=currentTask.taskIterations;if(energy>currentTask.energyPerItr){stepTime=currentTask.time;availableEnergy=energy-currentTask.energyPerItr;taskCount=taskCount+currentTask.taskWeight;currentTaskIterationNumber=currentTaskIterationNumber+1;if(_taskIterations===currentTaskIterationNumber){console.log(currentTask.taskName);console.log(\"task completion time\",simulationTime);if(currentTask.nextTask!==\"task_init\"){currentTaskIterationNumber=0;currentTaskNumber=currentTaskNumber+1;currentTask=configuration.tasks[currentTaskNumber];}else if(currentTask.nextTask===\"task_init\"){appCompleted=true;}}return availableEnergy;}else{stepTime=currentTask.time*(availableEnergy/currentTask.energyPerItr);hasBeenMax=false;powerFailureCount=powerFailureCount+1;availableEnergy=calculateEnergy(lowerThresholdVoltage);return availableEnergy;}}};calculateNewVoltage=function calculateNewVoltage(v,c,t){var newVoltage=1/capacitance*(c*t)+v;return newVoltage;};calculateRemainingVoltage=function calculateRemainingVoltage(energy){var voltage=Math.sqrt(2*(1/capacitance)*energy);return voltage;};calculateEnergy=function calculateEnergy(voltage){var maxEnergy=0.5*capacitance*voltage*voltage;return maxEnergy;};findClosestValue=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(arr,val){var closestValue;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:closestValue=arr.reduce(function(prev,curr){return Math.abs(curr-val)<Math.abs(prev-val)?curr:prev;});return _context.abrupt(\"return\",closestValue);case 2:case\"end\":return _context.stop();}}},_callee);}));return function findClosestValue(_x5,_x6){return _ref.apply(this,arguments);};}();extractTimeArray=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(arr){var newTimeArray,filteredArray,a;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:newTimeArray=[];filteredArray=arr.filter(function(_,i){return i%512==0;});for(a=0;a<filteredArray.length;a++){newTimeArray.push(filteredArray[a][0]);}return _context2.abrupt(\"return\",newTimeArray);case 4:case\"end\":return _context2.stop();}}},_callee2);}));return function extractTimeArray(_x7){return _ref2.apply(this,arguments);};}();extractVoltageArray=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(arr,time){var newVoltageArray,i,j;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:newVoltageArray=[];i=0;case 2:if(!(i<arr.length)){_context3.next=9;break;}if(!(arr[i][0]==time)){_context3.next=6;break;}for(j=i;j<512+i;j++){newVoltageArray.push(arr[j][1]);}return _context3.abrupt(\"break\",9);case 6:i++;_context3.next=2;break;case 9:return _context3.abrupt(\"return\",newVoltageArray);case 10:case\"end\":return _context3.stop();}}},_callee3);}));return function extractVoltageArray(_x8,_x9){return _ref3.apply(this,arguments);};}();findCurrentNow=function findCurrentNow(time,voltage){for(var i=0;i<rawData.length;i++){if(rawData[i][0]==time){for(var j=i;j<512+i;j++){if(rawData[j][1]==voltage){return rawData[j][2];}}}}};findAccuracyNow=function findAccuracyNow(){var skipRows=adaptiveVariablesValues.skipRows;var skipColumns=adaptiveVariablesValues.skipColumns;var accuracyMapString=\"\".concat(skipRows,\"_\").concat(skipColumns);var accuracyMapValue=configuration.accuracyMap[accuracyMapString];accuracyArray.push(accuracyMapValue);};handleMLAccuracy=function handleMLAccuracy(){if(accuracyArray.length>0){var averageAccuracy=accuracyArray.reduce(function(a,b){return a+b;})/accuracyArray.length;return averageAccuracy;}else{return 0;}};// Adaptation\nadaptUp=function adaptUp(){if(adapt){if(adaptiveVariablesValues[\"skipRows\"]!==lowerAdaptationThreshold){adaptiveVariablesValues[\"skipRows\"]=adaptiveVariablesValues[\"skipRows\"]-adaptationStepSize;}if(adaptiveVariablesValues[\"skipColumns\"]!==lowerAdaptationThreshold){adaptiveVariablesValues[\"skipColumns\"]=adaptiveVariablesValues[\"skipColumns\"]-adaptationStepSize;}}};adaptDown=function adaptDown(){if(adapt){if(adaptiveVariablesValues[\"skipRows\"]<upperAdaptationThreshold){adaptiveVariablesValues[\"skipRows\"]=adaptiveVariablesValues[\"skipRows\"]+adaptationStepSize;}if(adaptiveVariablesValues[\"skipColumns\"]<upperAdaptationThreshold){adaptiveVariablesValues[\"skipColumns\"]=adaptiveVariablesValues[\"skipColumns\"]+adaptationStepSize;}}};// Setup\n_context5.next=62;return getData();case 62:_context5.next=64;return extractTimeArray(rawData);case 64:timeArray=_context5.sent;adaptiveVariablesValues=initializeAdaptiveVariables(adaptiveVariables);// Main Script\ncase 66:if(!(simulationTime<timeArray[timeArray.length-1])){_context5.next=89;break;}// INSERT SOME LOGIC TO HANDLE TASKS HERE (POTENTIALLY)\nbootTime=0;executedTasks=false;// Call Charge Capacitor\n// 1) Check which timestamp is closest to simulation time\n_context5.next=71;return findClosestValue(timeArray,simulationTime);case 71:closestTimestamp=_context5.sent;_context5.next=74;return extractVoltageArray(rawData,closestTimestamp);case 74:voltageArray=_context5.sent;_context5.next=77;return findClosestValue(voltageArray,oldVoltage);case 77:closestVoltage=_context5.sent;// 3) Lookuptable based on those 2 values to find current\ncurrent=findCurrentNow(closestTimestamp,closestVoltage)*15;// 4) Calculate new voltage based on the current\nnewVoltage=calculateNewVoltage(oldVoltage,current,stepTime);// Check If capacitor hits upper threshold\nif(hasBeenMax===false&&newVoltage>=upperThresholdVoltage){hasBeenMax=true;energy=calculateEnergy(newVoltage);usefulEnergy=energy-calculateEnergy(lowerThresholdVoltage);remainingUsefulEnergy=usefulEnergy-MNIST.initOverheadEnergy;totalRemainingEnergy=remainingUsefulEnergy+calculateEnergy(lowerThresholdVoltage);newVoltage=calculateRemainingVoltage(totalRemainingEnergy);bootTime=MNIST.time;executedTasks=true;}if(hasBeenMax===true&&newVoltage<=lowerThresholdVoltage){hasBeenMax=false;}// Execute if capacitor voltage is within upper and lower thresholds\nif(newVoltage>=lowerThresholdVoltage&&hasBeenMax===true){_energy=calculateEnergy(newVoltage);_usefulEnergy=_energy-calculateEnergy(lowerThresholdVoltage);_remainingUsefulEnergy=executeTasks(_usefulEnergy);_totalRemainingEnergy=_remainingUsefulEnergy+calculateEnergy(lowerThresholdVoltage);oldVoltage=calculateRemainingVoltage(_totalRemainingEnergy);executedTasks=true;}else{stepTime=0.01;oldVoltage=newVoltage;executedTasks=false;taskCount=0;}// Increments simulation time\nsimulationTime=simulationTime+stepTime+bootTime;// Increments on/off time\nif(executedTasks){onTime=onTime+(stepTime+bootTime)*1000;}else{offTime=offTime+stepTime*1000;}appCompletionTime=onTime+offTime;// Handles App Completions\nif(appCompleted){appCompletions=appCompletions+1;appCompleted=false;// Push elements to the buffer\ns_onTime.unshift(onTime);s_onTime.pop();s_offTime.unshift(offTime);s_offTime.pop();s_appCompTime.unshift(appCompletionTime);s_appCompTime.pop();s_taskCount.unshift(taskCount);s_taskCount.pop();s_pFC.unshift(powerFailureCount);s_pFC.pop();console.log(\"onTime\",s_onTime);console.log(\"offTime\",s_offTime);console.log(\"app completion time\",s_appCompTime);console.log(\"taskCount\",s_taskCount);console.log(\"failure count\",s_pFC);console.log(\"skip Rows\",adaptiveVariablesValues[\"skipRows\"]);console.log(\"skip Columns\",adaptiveVariablesValues[\"skipColumns\"]);// Averaging\navgOnTime=average(s_onTime.slice(1,histArraySize));avgOffTime=average(s_offTime.slice(1,histArraySize));avgAppCompletionTime=average(s_appCompTime.slice(1,histArraySize));avgTaskCount=average(s_taskCount.slice(1,histArraySize));avgpowerFailureCount=average(s_pFC.slice(1,histArraySize));// Handles Graphical Display\nfindAccuracyNow();if(adaptiveVariablesValues[\"skipColumns\"]!==0||adaptiveVariablesValues[\"skipRows\"]!==0){accuracyReturn.push({Accuracy:accuracyArray[accuracyArray.length-1],Time:simulationTime,Adapted:true});}else if(adaptiveVariablesValues[\"skipColumns\"]==0||adaptiveVariablesValues[\"skipRows\"]==0){accuracyReturn.push({Accuracy:accuracyArray[accuracyArray.length-1],Time:simulationTime,Adapted:false});}// Adaptation\n// const shouldAdaptUp = evaluatex(equation.adaptUp,\n//     { s_onTime: s_onTime },\n//     { avgOnTime: avgOnTime },\n//     { s_offTime: s_offTime },\n//     { avgOffTime: avgOffTime },\n//     { s_appCompTime: s_appCompTime },\n//     { avgAppCompletionTime: avgAppCompletionTime },\n//     { s_taskCount: s_taskCount },\n//     { s_taskCount: s_taskCount },\n//     { avgTaskCount: avgTaskCount },\n//     { s_pFC: s_pFC },\n//     { avgpowerFailureCount: avgpowerFailureCount },\n//     { latex: true }\n// );\n// const shouldAdaptDown = evaluatex(equation.adaptDown,\n//     { s_onTime: s_onTime },\n//     { avgOnTime: avgOnTime },\n//     { s_offTime: s_offTime },\n//     { avgOffTime: avgOffTime },\n//     { s_appCompTime: s_appCompTime },\n//     { avgAppCompletionTime: avgAppCompletionTime },\n//     { s_taskCount: s_taskCount },\n//     { s_taskCount: s_taskCount },\n//     { avgTaskCount: avgTaskCount },\n//     { s_pFC: s_pFC },\n//     { avgpowerFailureCount: avgpowerFailureCount },\n//     { latex: true }\n// );\n// if (shouldAdaptUp()) {\n//     adaptDown();\n// }\n// else if (shouldAdaptDown()) {\n//     adaptUp();\n// }\n// if (equation.term1 === \"onTimeHistory\") {\n//     if (s_onTime[0] > avgOnTime) {\n//         adaptDown();\n//     }\n//     else if (s_onTime[0] < avgOnTime) {\n//         adaptUp();\n//     }\n// }\n// if (equation.term1 === \"offTimeHistory\") {\n//     if (s_offTime[0] > avgOffTime) {\n//         adaptDown();\n//     }\n//     else if (s_offTime[0] < avgOffTime) {\n//         adaptUp();\n//     }\n// }\n// if (equation.term1 === \"appCompletionTimeHistory\") {\n//     if (s_appCompTime[0] > 1000) { // this is checking milli-seconds\n//         adaptDown();\n//     }\n//     else if (s_appCompTime[0] < avgAppCompletionTime) {\n//         adaptUp();\n//     }\n// }\n// if (equation.term1 === \"taskCountHistory\") {\n//     if (s_taskCount[0] < avgTaskCount) {\n//         adaptDown();\n//     }\n//     else if (s_taskCount[0] > avgTaskCount) {\n//         adaptUp();\n//     }\n// }\n// if (equation.term1 === \"powerFailureCountHistory\") {\n//     if (s_pFC[0] > avgpowerFailureCount) {\n//         adaptDown();\n//     }\n//     else if (s_pFC[0] < avgpowerFailureCount) {\n//         adaptUp();\n//     }\n// }\n// Reset adaptation signals\nonTime=0;offTime=0;appCompletionTime=0;taskCount=0;powerFailureCount=0;currentTaskNumber=0;currentTaskIterationNumber=0;currentTask=configuration.tasks[currentTaskNumber];console.log(\"app completions\",appCompletions);}_context5.next=66;break;case 89:// Cleanup\nmlAccuracy=handleMLAccuracy();roundedAccuracy=mlAccuracy.toFixed(2);console.log(\"average accuracy of all classifications\",roundedAccuracy);console.log(accuracyReturn);// Return\nreturn _context5.abrupt(\"return\",{appCompletions:appCompletions,mlAccuracy:roundedAccuracy,accuracyGraph:accuracyReturn});case 94:case\"end\":return _context5.stop();}}},_callee5);}));return _Main.apply(this,arguments);}export default Main;","map":{"version":3,"sources":["/Users/aross/Desktop/adaptation-profiler/src/scripts/SimulationScript.js"],"names":["File","MNIST","csv2array","Main","histArraySize","stepSize","equation","adapt","getData","fetch","response","text","table","rawData","console","log","configuration","adaptationStrategy","capacitance","newVoltage","oldVoltage","current","simulationTime","hasBeenMax","timeArray","accuracyArray","accuracyReturn","bootTime","executedTasks","currentTask","tasks","currentTaskNumber","currentTaskIterationNumber","adaptiveVariables","equation1","adaptUp","split","equation2","pop","equation3","adaptDown","equation4","onTime","avgOnTime","s_onTime","Array","fill","offTime","avgOffTime","s_offTime","appCompletionTime","avgAppCompletionTime","s_appCompTime","taskCount","avgTaskCount","s_taskCount","powerFailureCount","avgpowerFailureCount","s_pFC","lowerAdaptationThreshold","upperAdaptationThreshold","adaptationStepSize","upperThresholdVoltage","lowerThresholdVoltage","stepTime","appCompletions","appCompleted","initializeAdaptiveVariables","variables","adaptiveVariablesValues","i","length","average","list","reduce","prev","curr","executeTasks","energy","availableEnergy","taskIterations","adaptiveVars","window","eval","energyPerItr","time","taskWeight","taskName","nextTask","calculateEnergy","calculateNewVoltage","v","c","t","calculateRemainingVoltage","voltage","Math","sqrt","maxEnergy","findClosestValue","arr","val","closestValue","abs","extractTimeArray","newTimeArray","filteredArray","filter","_","a","push","extractVoltageArray","newVoltageArray","j","findCurrentNow","findAccuracyNow","skipRows","skipColumns","accuracyMapString","accuracyMapValue","accuracyMap","handleMLAccuracy","averageAccuracy","b","closestTimestamp","voltageArray","closestVoltage","usefulEnergy","remainingUsefulEnergy","initOverheadEnergy","totalRemainingEnergy","unshift","slice","Accuracy","Time","Adapted","mlAccuracy","roundedAccuracy","toFixed","accuracyGraph"],"mappings":"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","sourcesContent":["import File from '../misc/test.csv';\nimport MNIST from '../config/mnist.json';\nimport csv2array from './CSVToArray';\n\nasync function Main(histArraySize, stepSize, equation, adapt) {\n\n    console.log(\"equation\", equation)\n\n    // Notes:\n    // - button for run simulation\n    // - report total executions on UI/UX\n    // - loading indicator during executions\n    // - at each app completion: find skip rows, and skip columns -> convert to a string in the form of 0_0 -> find value from accuracy dictionary (make a dictionary too) -> average these values -> report this as ML accuracy\n\n    // Configuration\n    const configuration = MNIST.adaptationStrategy[0];\n\n    // Initial Values\n    const capacitance = 200e-6; //micro-farads\n    let newVoltage = 0; //volts\n    let oldVoltage = 0 //volts\n    let current = 0; //amperes\n    let simulationTime = 0; //seconds\n    let hasBeenMax = false;\n    let rawData;\n\n    // Useful Utility Arrays\n    let timeArray = [];\n    let accuracyArray = [];\n    let accuracyReturn = [];\n\n    // Task Management Logic\n    let bootTime = 0;\n    let executedTasks = false;\n    let currentTask = configuration.tasks[0];\n    let currentTaskNumber = 0;\n    let currentTaskIterationNumber = 0;\n    let adaptiveVariables = configuration.adaptiveVariables;\n\n    // Adaptation Equations\n    const equation1 = equation.adaptUp.split('>');\n    const equation2 = equation.adaptUp.split('>').pop();\n    const equation3 = equation.adaptDown.split('<')[0];\n    const equation4 = equation.adaptDown.split('<').pop();\n\n    // Adaptation Signals\n    let onTime = 0;\n    let avgOnTime = 0;\n    let s_onTime = new Array(histArraySize + 1).fill(0);\n\n    let offTime = 0;\n    let avgOffTime = 0;\n    let s_offTime = new Array(histArraySize + 1).fill(0);\n\n    let appCompletionTime = 0;\n    let avgAppCompletionTime = 0;\n    let s_appCompTime = new Array(histArraySize + 1).fill(0);\n\n    let taskCount = 0;\n    let avgTaskCount = 0;\n    let s_taskCount = new Array(histArraySize + 1).fill(0);\n\n    let powerFailureCount = 0;\n    let avgpowerFailureCount = 0;\n    let s_pFC = new Array(histArraySize + 1).fill(0);\n\n    let lowerAdaptationThreshold = 0;\n    let upperAdaptationThreshold = 7;\n    let adaptationStepSize = stepSize;\n\n    // Threshold Logic\n    let upperThresholdVoltage = 2.9 //volts\n    let lowerThresholdVoltage = 1.9 //volts\n\n    // Step Logic\n    let stepTime = 0.01; //seconds\n\n    // Global Runs Logic\n    let appCompletions = 0;\n    let appCompleted = false;\n\n    // Functions Library\n\n    async function getData() {\n        const response = await fetch(File);\n        const table = await response.text();\n        rawData = csv2array(table);\n    }\n\n    const initializeAdaptiveVariables = (variables) => {\n        let adaptiveVariablesValues = {}\n        for (var i = 0; i < variables.length; i++) {\n            adaptiveVariablesValues[variables[i]] = 0;\n        }\n        return adaptiveVariablesValues;\n    }\n\n    const average = list => list.reduce((prev, curr) => prev + curr) / list.length;\n\n    const executeTasks = (energy) => {\n\n        let availableEnergy = energy;\n        if (typeof currentTask.taskIterations !== 'number') {\n            let taskIterations;\n            for (var i = 0; i < currentTask.adaptiveVars.length; i++) {\n                window[currentTask.adaptiveVars[i]] = adaptiveVariablesValues[currentTask.adaptiveVars[i]];\n            }\n            taskIterations = eval(currentTask.taskIterations);\n            if (energy > currentTask.energyPerItr) {\n                stepTime = currentTask.time;\n                availableEnergy = energy - currentTask.energyPerItr;\n                taskCount = taskCount + currentTask.taskWeight;\n                currentTaskIterationNumber = currentTaskIterationNumber + 1;\n                if (taskIterations == currentTaskIterationNumber) {\n                    console.log(currentTask.taskName);\n                    console.log(\"task completion time\", simulationTime);\n                    if (currentTask.nextTask !== \"task_init\") {\n                        currentTaskIterationNumber = 0;\n                        currentTaskNumber = currentTaskNumber + 1;\n                        currentTask = configuration.tasks[currentTaskNumber];\n                    } else if (currentTask.nextTask === \"task_init\") {\n                        appCompleted = true;\n                    }\n                }\n                return availableEnergy;\n            } else {\n                stepTime = currentTask.time * (availableEnergy / currentTask.energyPerItr);\n                hasBeenMax = false;\n                powerFailureCount = powerFailureCount + 1;\n                availableEnergy = calculateEnergy(lowerThresholdVoltage);\n                return availableEnergy;\n            }\n        } else {\n            const taskIterations = currentTask.taskIterations;\n            if (energy > currentTask.energyPerItr) {\n                stepTime = currentTask.time;\n                availableEnergy = energy - currentTask.energyPerItr;\n                taskCount = taskCount + currentTask.taskWeight;\n                currentTaskIterationNumber = currentTaskIterationNumber + 1;\n                if (taskIterations === currentTaskIterationNumber) {\n                    console.log(currentTask.taskName);\n                    console.log(\"task completion time\", simulationTime);\n                    if (currentTask.nextTask !== \"task_init\") {\n                        currentTaskIterationNumber = 0;\n                        currentTaskNumber = currentTaskNumber + 1;\n                        currentTask = configuration.tasks[currentTaskNumber];\n                    } else if (currentTask.nextTask === \"task_init\") {\n                        appCompleted = true;\n                    }\n                }\n                return availableEnergy;\n            } else {\n                stepTime = currentTask.time * (availableEnergy / currentTask.energyPerItr)\n                hasBeenMax = false;\n                powerFailureCount = powerFailureCount + 1;\n                availableEnergy = calculateEnergy(lowerThresholdVoltage);\n                return availableEnergy;\n            }\n        }\n    }\n\n    const calculateNewVoltage = (v, c, t) => {\n        const newVoltage = ((1 / capacitance) * ((c) * (t))) + v;\n        return newVoltage\n    }\n\n    const calculateRemainingVoltage = (energy) => {\n        const voltage = Math.sqrt(2 * (1 / capacitance) * (energy));\n        return voltage\n    }\n\n    const calculateEnergy = (voltage) => {\n        const maxEnergy = (0.5) * (capacitance) * (voltage) * (voltage);\n        return maxEnergy\n    }\n\n    const findClosestValue = async (arr, val) => {\n        const closestValue = arr.reduce(function (prev, curr) {\n            return (Math.abs(curr - val) < Math.abs(prev - val) ? curr : prev);\n        });\n        return closestValue;\n    }\n\n    const extractTimeArray = async (arr) => {\n        let newTimeArray = []\n        let filteredArray = arr.filter((_, i) => i % 512 == 0);\n        for (var a = 0; a < filteredArray.length; a++) {\n            newTimeArray.push(filteredArray[a][0]);\n        }\n        return newTimeArray\n    }\n\n    const extractVoltageArray = async (arr, time) => {\n        let newVoltageArray = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i][0] == time) {\n                for (var j = i; j < 512 + i; j++) {\n                    newVoltageArray.push(arr[j][1]);\n                }\n                break;\n            }\n        }\n        return newVoltageArray\n    }\n\n    const findCurrentNow = (time, voltage) => {\n        for (var i = 0; i < rawData.length; i++) {\n            if (rawData[i][0] == time) {\n                for (var j = i; j < 512 + i; j++) {\n                    if (rawData[j][1] == voltage) {\n                        return rawData[j][2]\n                    }\n                }\n            }\n        }\n    }\n\n    const findAccuracyNow = () => {\n        const skipRows = adaptiveVariablesValues.skipRows;\n        const skipColumns = adaptiveVariablesValues.skipColumns;\n        const accuracyMapString = `${skipRows}_${skipColumns}`;\n        const accuracyMapValue = configuration.accuracyMap[accuracyMapString];\n        accuracyArray.push(accuracyMapValue);\n    }\n\n    const handleMLAccuracy = () => {\n        if (accuracyArray.length > 0) {\n            const averageAccuracy = accuracyArray.reduce((a, b) => a + b) / accuracyArray.length;\n            return averageAccuracy;\n        } else {\n            return 0;\n        }\n    }\n\n    // Adaptation\n    const adaptUp = () => {\n        if (adapt) {\n            if (adaptiveVariablesValues[\"skipRows\"] !== lowerAdaptationThreshold) {\n                adaptiveVariablesValues[\"skipRows\"] = adaptiveVariablesValues[\"skipRows\"] - adaptationStepSize;\n            }\n            if (adaptiveVariablesValues[\"skipColumns\"] !== lowerAdaptationThreshold) {\n                adaptiveVariablesValues[\"skipColumns\"] = adaptiveVariablesValues[\"skipColumns\"] - adaptationStepSize;\n            }\n        }\n    }\n\n    const adaptDown = () => {\n        if (adapt) {\n            if (adaptiveVariablesValues[\"skipRows\"] < upperAdaptationThreshold) {\n                adaptiveVariablesValues[\"skipRows\"] = adaptiveVariablesValues[\"skipRows\"] + adaptationStepSize;\n            }\n            if (adaptiveVariablesValues[\"skipColumns\"] < upperAdaptationThreshold) {\n                adaptiveVariablesValues[\"skipColumns\"] = adaptiveVariablesValues[\"skipColumns\"] + adaptationStepSize;\n            }\n        }\n    }\n\n    // Setup\n\n    await getData();\n    timeArray = await extractTimeArray(rawData);\n    const adaptiveVariablesValues = initializeAdaptiveVariables(adaptiveVariables);\n\n    // Main Script\n\n    while (simulationTime < timeArray[timeArray.length - 1]) {\n\n        // INSERT SOME LOGIC TO HANDLE TASKS HERE (POTENTIALLY)\n\n        bootTime = 0;\n\n        executedTasks = false;\n\n        // Call Charge Capacitor\n\n        // 1) Check which timestamp is closest to simulation time\n        const closestTimestamp = await findClosestValue(timeArray, simulationTime);\n        // console.log(\"closest Timestamp\", closestTimestamp)\n        // 1.5) Get array of voltages that corresponds to the given timestamp \n        const voltageArray = await extractVoltageArray(rawData, closestTimestamp);\n        // 2) Find which voltage closely coresponds to oldVoltage within this IV curve\n        const closestVoltage = await findClosestValue(voltageArray, oldVoltage);\n        // 3) Lookuptable based on those 2 values to find current\n        current = findCurrentNow(closestTimestamp, closestVoltage) * 15;\n        // 4) Calculate new voltage based on the current\n        newVoltage = calculateNewVoltage(oldVoltage, current, stepTime);\n\n        // Check If capacitor hits upper threshold\n        if (hasBeenMax === false && newVoltage >= upperThresholdVoltage) {\n            hasBeenMax = true;\n            const energy = calculateEnergy(newVoltage)\n            const usefulEnergy = energy - calculateEnergy(lowerThresholdVoltage);\n            const remainingUsefulEnergy = usefulEnergy - MNIST.initOverheadEnergy;\n            const totalRemainingEnergy = remainingUsefulEnergy + calculateEnergy(lowerThresholdVoltage);\n            newVoltage = calculateRemainingVoltage(totalRemainingEnergy)\n            bootTime = MNIST.time;\n            executedTasks = true;\n        }\n\n        if (hasBeenMax === true && newVoltage <= lowerThresholdVoltage) {\n            hasBeenMax = false;\n        }\n\n        // Execute if capacitor voltage is within upper and lower thresholds\n        if (newVoltage >= lowerThresholdVoltage && hasBeenMax === true) {\n            const energy = calculateEnergy(newVoltage);\n            const usefulEnergy = energy - calculateEnergy(lowerThresholdVoltage);\n            const remainingUsefulEnergy = executeTasks(usefulEnergy);\n            const totalRemainingEnergy = remainingUsefulEnergy + calculateEnergy(lowerThresholdVoltage);\n            oldVoltage = calculateRemainingVoltage(totalRemainingEnergy);\n            executedTasks = true;\n        } else {\n            stepTime = 0.01;\n            oldVoltage = newVoltage;\n            executedTasks = false;\n            taskCount = 0;\n        }\n\n        // Increments simulation time\n        simulationTime = simulationTime + stepTime + bootTime;\n\n        // Increments on/off time\n        if (executedTasks) {\n            onTime = onTime + ((stepTime + bootTime) * 1000);\n        } else {\n            offTime = offTime + (stepTime * 1000);\n        }\n        appCompletionTime = onTime + offTime;\n\n        // Handles App Completions\n        if (appCompleted) {\n            appCompletions = appCompletions + 1;\n            appCompleted = false;\n\n            // Push elements to the buffer\n            s_onTime.unshift(onTime);\n            s_onTime.pop();\n            s_offTime.unshift(offTime);\n            s_offTime.pop();\n            s_appCompTime.unshift(appCompletionTime);\n            s_appCompTime.pop();\n            s_taskCount.unshift(taskCount);\n            s_taskCount.pop();\n            s_pFC.unshift(powerFailureCount);\n            s_pFC.pop();\n            console.log(\"onTime\", s_onTime);\n            console.log(\"offTime\", s_offTime);\n            console.log(\"app completion time\", s_appCompTime);\n            console.log(\"taskCount\", s_taskCount);\n            console.log(\"failure count\", s_pFC);\n            console.log(\"skip Rows\", adaptiveVariablesValues[\"skipRows\"]);\n            console.log(\"skip Columns\", adaptiveVariablesValues[\"skipColumns\"]);\n\n            // Averaging\n            avgOnTime = average(s_onTime.slice(1, histArraySize));\n            avgOffTime = average(s_offTime.slice(1, histArraySize));\n            avgAppCompletionTime = average(s_appCompTime.slice(1, histArraySize));\n            avgTaskCount = average(s_taskCount.slice(1, histArraySize));\n            avgpowerFailureCount = average(s_pFC.slice(1, histArraySize));\n\n            // Handles Graphical Display\n            findAccuracyNow();\n            if (adaptiveVariablesValues[\"skipColumns\"] !== 0 || adaptiveVariablesValues[\"skipRows\"] !== 0) {\n                accuracyReturn.push({ Accuracy: accuracyArray[accuracyArray.length - 1], Time: simulationTime, Adapted: true })\n            } else if (adaptiveVariablesValues[\"skipColumns\"] == 0 || adaptiveVariablesValues[\"skipRows\"] == 0) {\n                accuracyReturn.push({ Accuracy: accuracyArray[accuracyArray.length - 1], Time: simulationTime, Adapted: false })\n            }\n\n            // Adaptation\n\n            // const shouldAdaptUp = evaluatex(equation.adaptUp,\n            //     { s_onTime: s_onTime },\n            //     { avgOnTime: avgOnTime },\n            //     { s_offTime: s_offTime },\n            //     { avgOffTime: avgOffTime },\n            //     { s_appCompTime: s_appCompTime },\n            //     { avgAppCompletionTime: avgAppCompletionTime },\n            //     { s_taskCount: s_taskCount },\n            //     { s_taskCount: s_taskCount },\n            //     { avgTaskCount: avgTaskCount },\n            //     { s_pFC: s_pFC },\n            //     { avgpowerFailureCount: avgpowerFailureCount },\n            //     { latex: true }\n            // );\n\n            // const shouldAdaptDown = evaluatex(equation.adaptDown,\n            //     { s_onTime: s_onTime },\n            //     { avgOnTime: avgOnTime },\n            //     { s_offTime: s_offTime },\n            //     { avgOffTime: avgOffTime },\n            //     { s_appCompTime: s_appCompTime },\n            //     { avgAppCompletionTime: avgAppCompletionTime },\n            //     { s_taskCount: s_taskCount },\n            //     { s_taskCount: s_taskCount },\n            //     { avgTaskCount: avgTaskCount },\n            //     { s_pFC: s_pFC },\n            //     { avgpowerFailureCount: avgpowerFailureCount },\n            //     { latex: true }\n            // );\n\n            // if (shouldAdaptUp()) {\n            //     adaptDown();\n            // }\n            // else if (shouldAdaptDown()) {\n            //     adaptUp();\n            // }\n\n            // if (equation.term1 === \"onTimeHistory\") {\n            //     if (s_onTime[0] > avgOnTime) {\n            //         adaptDown();\n            //     }\n            //     else if (s_onTime[0] < avgOnTime) {\n            //         adaptUp();\n            //     }\n            // }\n\n            // if (equation.term1 === \"offTimeHistory\") {\n            //     if (s_offTime[0] > avgOffTime) {\n            //         adaptDown();\n            //     }\n            //     else if (s_offTime[0] < avgOffTime) {\n            //         adaptUp();\n            //     }\n            // }\n\n            // if (equation.term1 === \"appCompletionTimeHistory\") {\n            //     if (s_appCompTime[0] > 1000) { // this is checking milli-seconds\n            //         adaptDown();\n            //     }\n            //     else if (s_appCompTime[0] < avgAppCompletionTime) {\n            //         adaptUp();\n            //     }\n            // }\n\n            // if (equation.term1 === \"taskCountHistory\") {\n            //     if (s_taskCount[0] < avgTaskCount) {\n            //         adaptDown();\n            //     }\n            //     else if (s_taskCount[0] > avgTaskCount) {\n            //         adaptUp();\n            //     }\n            // }\n\n            // if (equation.term1 === \"powerFailureCountHistory\") {\n            //     if (s_pFC[0] > avgpowerFailureCount) {\n            //         adaptDown();\n            //     }\n            //     else if (s_pFC[0] < avgpowerFailureCount) {\n            //         adaptUp();\n            //     }\n            // }\n\n            // Reset adaptation signals\n            onTime = 0;\n            offTime = 0;\n            appCompletionTime = 0;\n            taskCount = 0;\n            powerFailureCount = 0;\n            currentTaskNumber = 0;\n            currentTaskIterationNumber = 0;\n            currentTask = configuration.tasks[currentTaskNumber];\n            console.log(\"app completions\", appCompletions);\n        }\n\n    }\n\n    // Cleanup\n\n    const mlAccuracy = handleMLAccuracy();\n    const roundedAccuracy = mlAccuracy.toFixed(2);\n    console.log(\"average accuracy of all classifications\", roundedAccuracy)\n    console.log(accuracyReturn)\n\n    // Return\n\n    return ({\n        appCompletions: appCompletions,\n        mlAccuracy: roundedAccuracy,\n        accuracyGraph: accuracyReturn\n    })\n\n}\n\nexport default Main"]},"metadata":{},"sourceType":"module"}